----CHAPTER-04
----WINDOWS FUNCTION
----AGGREGATED WINDOWS FUNCTION

--SET NOCOUNT ON;
--USE tempdb;

--ORDERVALUE TABLE
IF OBJECT_ID(N'DBO.ORDERVALUES', N'U') IS NOT NULL DROP TABLE DBO.ORDERVALUES;

SELECT * INTO DBO.ORDERVALUES FROM TSQLV3.Sales.OrderValues

ALTER TABLE DBO.ORDERVALUES ADD CONSTRAINT PK_ORDERVALUES PRIMARY KEY (ORDERID);

GO

--EMPORDERS TABLE

IF OBJECT_ID(N'DBO.EMPORDERS', N'U') IS NOT NULL DROP TABLE DBO.EMPORDERS;

SELECT empid, ISNULL(ordermonth, CAST('19000101' AS DATE)) AS ordermonth, qty,
val, numorders
INTO DBO.EMPORDERS
FROM TSQLV3.Sales.EmpOrders;

ALTER TABLE DBO.EMPORDERS ADD CONSTRAINT PK_EMPORDERS PRIMARY KEY(EMPID, ORDERMONTH);
GO

--TRANSATIONS TABLE 

-- Transactions table
IF OBJECT_ID('dbo.Transactions', 'U') IS NOT NULL DROP TABLE dbo.Transactions;
IF OBJECT_ID('dbo.Accounts', 'U') IS NOT NULL DROP TABLE dbo.Accounts;

CREATE TABLE dbo.Accounts
(
actid INT NOT NULL CONSTRAINT PK_Accounts PRIMARY KEY
);

CREATE TABLE dbo.Transactions
(
actid INT NOT NULL,
tranid INT NOT NULL,
val MONEY NOT NULL,
CONSTRAINT PK_Transactions PRIMARY KEY(actid, tranid)
);

DECLARE 
@NUM_PARTITIONS AS INT = 100, 
@ROWS_PER_PARTITION AS INT = 2000;


INSERT INTO DBO.ACCOUNTS WITH (TABLOCK) (ACTID) 
SELECT NP.N
FROM TSQLV3.DBO.GETNUMS(1, @NUM_PARTITIONS) AS NP;

INSERT INTO DBO.TRANSACTIONS WITH (TABLOCK)  (ACTID, TRANID, VAL)
SELECT NP.N, RPP.N, 
(ABS(CHECKSUM(NEWID())%2)*2-1) * (1+ abs(CHECKSUM(NEWID())%5))
FROM TSQLV3.DBO.GetNums(1, @NUM_PARTITIONS) AS np
CROSS JOIN TSQLV3.DBO.GetNums(1, @ROWS_PER_PARTITION) AS RPP;


 --LIMITATION PG344 working on queries at work
 --WINDOWS ELEMENT 


--SELECT EMPID, ORDERMONTH, QTY, 
--SUM(QTY) over (partition BY EMPID ORDER BY ORDERMONTH ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS RUNQTY
--FROM DBO.EMPORDERS;

-- PG 348 WINDOWS PARITION 

--SELECT orderid, custid, val, 

--CAST(100. *  VAL / SUM(VAL) OVER() AS NUMERIC (5,2)) AS PCTALL, 
--CAST(100. *  VAL / SUM(VAL) OVER (PARTITION BY CUSTID)  AS NUMERIC (5,2)) AS PCTCUST
--FROM DBO.ORDERVALUES
--ORDER BY CUSTID


SELECT ACTID, TRANID, VAL, 
VAL / SUM(VAL) over() AS PCTALL, 
VAL / SUM(VAL) OVER(PARTITION BY ACTID) AS  PCTAT
FROM DBO.Transactions

WITH GRANDAGG AS 
(
SELECT SUM(VAL) AS SUMALL FROM DBO.Transactions
), 

ACTAGG AS 
(
SELECT ACTID, SUM(VAL) AS SUMACT FROM 
DBO.Transactions
GROUP BY actid
)

SELECT T.actid, T.tranid, T.val, 
T.VAL/GA.SUMALL AS PCTALL,
T.VAL/AA.SUMACT AS PCTALL
FROM DBO.Transactions AS T
CROSS JOIN GRANDAGG AS GA
INNER JOIN ACTAGG AS AA
ON AA.ACTID = T.actid


SELECT CUSTID, SUM(VAL) AS CUSTOTAL
FROM DBO.ORDERVALUES
GROUP BY custid

SELECT CUSTID, SUM(VAL) AS CUSTOTAL,
SUM(VAL)/SUM(SUM(VAL)) over() AS PCT
FROM DBO.ORDERVALUES
GROUP BY custid

-356


SELECT empid, ordermonth, QTY,
SUM(QTY) OVER (PARTITION BY EMPID ORDER BY ORDERMONTH ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RUNQTY

FROM DBO.EMPORDERS




SELECT custid, ORDERID, VAL, ORDERDATE, 

SUM(VAL) OVER (PARTITION BY  CUSTID, YEAR(ORDERDATE) ORDER BY ORDERDATE RANGE UNBOUNDED PRECEDING) AS YTD_VAL
FROM DBO.ORDERVALUES

SET NOCOUNT ON;
USE tempdb;
IF OBJECT_ID(N'dbo.Orders', N'U') IS NOT NULL DROP TABLE dbo.Orders;
CREATE TABLE dbo.Orders
(
orderid INT NOT NULL,
orderdate DATE NOT NULL,
empid INT NOT NULL,
custid VARCHAR(5) NOT NULL,
qty INT NOT NULL,
CONSTRAINT PK_Orders PRIMARY KEY (orderid)
);
GO
INSERT INTO dbo.Orders(orderid, orderdate, empid, custid, qty)
VALUES(30001, '20130802', 3, 'B', 10),
(10001, '20131224', 1, 'C', 10),
(10005, '20131224', 1, 'A', 30),
(40001, '20140109', 4, 'A', 40),
(10006, '20140118', 1, 'C', 10),
(20001, '20140212', 2, 'B', 20),
(40005, '20140212', 4, 'A', 10),
(20002, '20140216', 2, 'C', 20),
(30003, '20140418', 3, 'B', 15),
(30004, '20140418', 3, 'B', 20),
(30007, '20140907', 3, 'C', 30);


SELECT ORDERID, QTY, 
ROW_NUMBER() Over( ORDER BY QTY, ORDERID) AS ROWNUM, 
RANK() Over( ORDER BY QTY) AS RANK,
DENSE_RANK() over(ORDER BY QTY) AS DENSERANK,
NTILE(4) OVER (ORDER BY QTY) AS NTILE
FROM DBO.Orders





SELECT CUSTID, ORDERID, QTY, 
ROW_NUMBER() Over( PARTITION BY CUSTID ORDER BY ORDERID) AS ROWNUM
FROM DBO.Orders


-- OFFSET WINDOWS FUNCTION PG 374

-- FIRST_VALUE AND LAST_VALUE

SELECT  CUSTID, ORDERID, ORDERDATE, QTY, 
FIRST_VALUE(QTY) over(PARTITION BY CUSTID 
						ORDER BY ORDERDATE, ORDERID 
						ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS FIRSTQTY, 
LAST_VALUE(QTY) OVER(PARTITION BY CUSTID 
					ORDER BY ORDERDATE, ORDERID
					ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS LASTQTY

FROM DBO.ORDERS
ORDER BY CUSTID, ORDERDATE, ORDERID

-- LAG AND LEAD

SELECT  CUSTID, ORDERID, ORDERDATE, QTY, 
LAG(QTY) over(PARTITION BY CUSTID 
						ORDER BY ORDERDATE, ORDERID 
						) AS PREQTY, 
LEAD(QTY) OVER(PARTITION BY CUSTID 
					ORDER BY ORDERDATE, ORDERID
					) AS NEXTQTY

FROM DBO.ORDERS
ORDER BY CUSTID, ORDERDATE, ORDERID

--STATISTICAL WINDOW FUNCTION

-- RANK DISTRIBUTION FUNCTION

USE TSQLV3

SELECT TESTID, STUDENTID, SCORE, 
CAST(100.00 * PERCENT_RANK() OVER(PARTITION BY TESTID ORDER BY SCORE)AS NUMERIC (5,2) ) AS PERCENTRANK, 
CAST(100.00* CUME_DIST() OVER(PARTITION BY TESTID ORDER BY SCORE) AS NUMERIC (5,2)) AS CIMEDIST
FROM STATS.SCORES;

SELECT TESTID, STUDENTID, SCORE,
PERCENTILE_DISC(0.5) WITHIN GROUP(ORDER BY SCORE) OVER (PARTITION BY TESTID) AS MEDIANDISC, 
PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY SCORE) OVER (PARTITION BY TESTID) AS MEDIANCOUT
FROM STATS.Scores


SELECT DISTINCT TESTID,
PERCENTILE_DISC(0.5) WITHIN GROUP(ORDER BY SCORE) OVER (PARTITION BY TESTID) AS MEDIANDISC, 
PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY SCORE) OVER (PARTITION BY TESTID) AS MEDIANCOUT
FROM STATS.Scores

--GAPS AND ISLANDS

SET NOCOUNT ON;
USE tempdb;
IF OBJECT_ID('dbo.T1', 'U') IS NOT NULL DROP TABLE dbo.T1;
CREATE TABLE dbo.T1(col1 INT NOT NULL CONSTRAINT PK_T1 PRIMARY KEY);
GO
INSERT INTO dbo.T1(col1) VALUES(1),(2),(3),(7),(8),(9),(11),(15),(16),(17),
(28);

SELECT COL1 AS CURR, LEAD(COL1) OVER(ORDER BY COL1) AS NXT
FROM DBO.T1

WITH C AS 
(
SELECT COL1 AS CURR, LEAD(COL1) OVER(ORDER BY COL1) AS NXT
FROM DBO.T1
)

SELECT CURR+1 AS RANGE_FROM, NXT -1 AS RANGE_TO
FROM C  
WHERE NXT - CURR > 1

--ISLAND

SELECT COL1, ROW_NUMBER() OVER(ORDER BY COL1) AS ROWNUM
FROM DBO.T1

SELECT COL1, COL1 - ROW_NUMBER() OVER(ORDER BY COL1) AS ROWNUM
FROM DBO.T1

WITH CC AS (
SELECT COL1, COL1 - ROW_NUMBER() OVER(ORDER BY COL1) AS ROWNUM
FROM DBO.T1)

SELECT MIN(COL1) AS RANGE_FROM, MAX(COL1) AS RANGE_TO
FROM CC 
GROUP BY ROWNUM


USE TSQLV3;
CREATE UNIQUE INDEX idx_sid_sd_oid
ON Sales.Orders(shipperid, shippeddate, orderid)
WHERE shippeddate IS NOT NULL;


WITH T AS 
(
SELECT shipperid, shippeddate, 
DATEADD(
DAY, -1 * DENSE_RANK() OVER (PARTITION BY SHIPPERID ORDER BY SHIPPEDDATE), shippeddate) AS GRP

FROM Sales.Orders
WHERE shippeddate IS NOT NULL
)

SELECT SHIPPERID, MIN(shippeddate) AS FROMDATE, MAX(shippeddate) AS MAXDATE, COUNT(*) AS NUMORDERS

FROM T
GROUP BY SHIPPERID, GRP

PG 386

SELECT SHIPPERID, SHIPPEDDATE, ORDERID, 
CASE WHEN DATEDIFF(DAY, 
	LAG(SHIPPEDDATE) OVER(PARTITION BY SHIPPERID ORDER BY SHIPPEDDATE, ORDERID), 
		SHIPPEDDATE) < = 7 THEN 0 ELSE 1 END AS STARFLAG
		FROM SALES.ORDERS
		WHERE SHIPPEDDATE IS NOT NULL

WITH C1 AS (
SELECT SHIPPERID, SHIPPEDDATE, ORDERID, 
CASE WHEN DATEDIFF(DAY, 
	LAG(SHIPPEDDATE) OVER(PARTITION BY SHIPPERID ORDER BY SHIPPEDDATE, ORDERID), 
		SHIPPEDDATE) < = 7 THEN 0 ELSE 1 END AS STARFLAG
		FROM SALES.ORDERS
		WHERE SHIPPEDDATE IS NOT NULL
		), 
		C2 AS (
SELECT *, sum(STARFLAG) OVER (PARTITION BY SHIPPERID ORDER BY SHIPPEDDATE, ORDERID ROWS UNBOUNDED PRECEDING ) AS GRP
FROM C1
)

SELECT SHIPPERID, MIN(SHIPPEDDATE) AS FROMDATE, 
MAX(SHIPPEDDATE) AS TODATE, 
COUNT(*) AS NUMORDERS
FROM C2 GROUP BY 
SHIPPERID, GRP;